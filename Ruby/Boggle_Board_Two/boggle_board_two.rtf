{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf160
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Italic;
\f3\fnil\fcharset0 HelveticaNeue-Medium;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red255\green255\blue255;\red184\green14\blue61;
\red247\green238\blue241;\red242\green242\blue242;\red83\green83\blue83;\red115\green0\blue2;\red169\green14\blue26;
\red51\green110\blue109;\red14\green115\blue192;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww20380\viewh12640\viewkind0
\deftab720
\pard\pardeftab720\sl400\sa200

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Using your basic 
\f1\fs22 \cf4 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 BoggleBoard
\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2  generator from before, we're now going to model a person checking whether a given word is on the Boggle board or not.\cb1 \
\cb3 The only rule is that the same dice can't be reused in the same word, i.e., the "word path" can't ever cross itself.\cb1 \
\cb3 We'll implement a 
\f1\fs22 \cf4 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 BoggleBoard#include?
\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2  method which works like this:\cb1 \
\pard\pardeftab720\sl320

\f1\fs24 \cf2 \cb6 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 board \cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 =\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2  \cf8 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec8 BoggleBoard\cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 .\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 new\
board\cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 .\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 shake!\
board\cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 .\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 include?(\cf9 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec9 "apple"\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 ) 
\f2\i \cf10 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec10 # => true or false, depending
\f1\i0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\pard\pardeftab720\sl400\sa200

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Note
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 : This method won't care whether the input is 
\i \expnd0\expndtw0\kerning0
\outl0\strokewidth0 actually
\i0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  a word in a dictionary. It will just tell your whether the string, as its input, is on the Boggle board.\cb1 \
\pard\pardeftab720\sl800\sa200

\f3\fs60 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 External Resources\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl400
\ls1\ilvl0
\f0\fs28 \cf11 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}{\field{\*\fldinst{HYPERLINK "http://en.wikipedia.org/wiki/Boggle"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec11 Boggle on Wikipedia}}\cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\ls1\ilvl0\cf11 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}{\field{\*\fldinst{HYPERLINK "http://www.wordplays.com/boggle"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec11 Play Boggle online}}\cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\pard\pardeftab720\sl800\sa200

\f3\fs60 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Learning Goals\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl400
\ls2\ilvl0
\f0\fs28 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Modeling a simple real-world procedure in Ruby\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Method definition, arguments, and return values\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Common string methods\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Simple algorithms and data structures\cb1 \
\pard\pardeftab720\sl800\sa200

\f3\fs60 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Objectives\cb1 \
\pard\pardeftab720\sl600\sa200

\fs48 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Pseudocode for 
\f1\fs22 \cf4 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 BoggleBoard#include?
\f3\fs48 \cf2 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\pard\pardeftab720\sl400\sa200

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Take a step back. Breathe. I know you want to jump right in and start writing code. But don't! It's a trap!\cb1 \
\cb3 Get a pen and paper and draw out a 4-by-4 Boggle board. Imagine it filled with letters. Or actually fill it with letters if you like \'97 maybe using your Boggle board generator.\cb1 \
\cb3 Have your pair spell out a word for you and verify yourself whether its on the board. It might help if the word is gibberish and not English so that you're forced to check letter-by-letter and can short-circuit the English-reading part of your brain.\cb1 \
\cb3 As clearly and precisely as you can reflect your internal mental process. Can you explain it to your pair? Draw it, verbalize it, or do whatever is easiest for you, but make sure you and your pair are clear about it.\cb1 \
\cb3 Initially, let's do a simpler, less interesting version of Boggle. Instead of being able to string together letters that are connected in any direction, let's just focus on words that appear in a 
\b \expnd0\expndtw0\kerning0
\outl0\strokewidth0 continuous line
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  vertically, horizontally, and diagonally. (Remember, only words 3 or more letters count!)\cb1 \
\cb3 Write pseudocode for your algorithm. If you're feeling adventurous, you and your pair could each write your own pseudocode and compare.\cb1 \
\cb3 How do your stylistic approaches compare? Your respective vocabulary? The overall structure and strategy of your approach?\cb1 \
\pard\pardeftab720\sl600\sa200

\f3\fs48 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Implement 
\f1\fs22 \cf4 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 BoggleBoard#include?
\f3\fs48 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2  in Ruby\cb1 \
\pard\pardeftab720\sl400\sa200

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 If you went through the exercise above, your job is now to just translate your pseudocode into Ruby.\cb1 \
\cb3 What new instance methods do you need to define? Would your algorithm be easier to implement if your board were stored differently?\cb1 \
\cb3 For example, what are the tradeoffs between storing the board as a 4x4 array of arrays versus a single 16-element array?\cb1 \
\pard\pardeftab720\sl600\sa200

\f3\fs48 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Going Deeper (Extra Credit)\cb1 \
\pard\pardeftab720\sl400\sa200

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Now try implementing your algorithm for the real boggle rules! The words don't have to be in continuous lines, they can be connected in any way, diagonally, vertically, horizontally, in any order. IE. Words can snake themselves across the board willy-nilly.\cb1 \
\cb3 What do you need to change to accommodate this added requirement? Does it make sense to change the structure of your board? Again, model this before coding, make sure you are aware of all the cases.\cb1 \
\pard\pardeftab720\sl360

\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \
}